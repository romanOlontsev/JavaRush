task1601

Лишь бы не в понедельник:)

Проинициализируй переменную birthDate объектом Date с датой своего рождения. Реализуй метод getDayOfWeek(Date date), 
чтобы он возвращал русское название дня недели аргумента date.

***

task1602

Подчищаем хвосты

Метод fixDate принимает в качестве параметра список дат. Некоторые из них содержат две типичные ошибки: неправильно 
сохраняются (и, следовательно, выводятся в консоли) год и месяц. То есть, неправильная дата содержит всегда две ошибки 
(год и месяц), которые тебе нужно исправить в методе fixDate, учитывая эти условия:
1. Если дата больше текущей, в ней нужно исправить эти две ошибки (год и месяц) с помощью методов setYear, setMonth. 
Год задается с 1900, а месяцы нумеруются с нуля.
2. Если дата меньше текущей, в ней ничего исправлять не нужно.

Пример даты с ошибками:

    Должно быть 25 декабря 2015 года, но на самом деле это другая дата.
    Можно посмотреть вывод в консоль для этой даты - new Date(2015, 12, 25, 20, 40).
    
***

task1603

Чиним формат

Исправь ошибку, чтобы программа вывела "2010-01-06". Инициализацию переменной date не меняй.

***

task1604

День недели рождения твоего

Проинициализируй переменную birthDate объектом GregorianCalendar с датой своего рождения. Реализуй метод 
getDayOfWeek(Calendar calendar), чтобы он возвращал русское название дня недели аргумента calendar. Помни, что в 
григорианском календаре неделя начинается с воскресенья.

***

task1605

Карманный телепорт

В классе Solution константа INVENTION_DAY содержит дату изобретения нового популярного гаджета — карманного телепорта. 
Реализуй метод isTeleportInvented, который в качестве параметра принимает дату и сравнивает ее с INVENTION_DAY. Если 
переданная дата следует после даты изобретения, нужно вывести надпись: "Пожалуйста, можете забрать ваш карманный 
телепорт. Спасибо за ожидание!" — и вернуть true. Если переданная дата предшествует дате изобретения, вывести: 
"Извините, телепорт еще не изобрели, приходите через 10 лет." — и вернуть false. В методе main в цикле вызови 
isTeleportInvented и передай currentDay в качестве параметра. Если метод возвращает false, прибавь к currentDay 10 лет, 
иначе — выйди из цикла.

***

task1606

Выход из зацикленности

Цикл while должен был завершиться за 31 итерацию, но почему-то зациклился. Найди и исправь ошибку.

***

task1607

Освоение нового API

В классе Solution реализуй 4 метода: - метод nowExample должен вернуть текущую дату; - остальные методы должны вернуть 
дату 12 сентября 2020 года, но разными способами.

***

task1608

Просто день недели

Реализуй метод getDayOfWeek(LocalDate date), чтобы он возвращал русское название дня недели аргумента date. 
Воспользуйся методами getDayOfWeek и getDisplayName. Пример параметров метода getDisplayName, чтобы получить русское 
название дня недели: getDisplayName(TextStyle.FULL, Locale.forLanguageTag("ru"))

***

task1609

С годами моложе

В 2010 году человеку исполнилось 40 лет. Мы попытались вычислить год, когда ему исполнилось 30 лет, и программа выдала 
2020 год. Как такое возможно? Измени один символ в коде, чтобы программа вывела 2000 год.

***

task1610

Тренировка на время

Инициализируй шесть статических переменных: - в timeMax запиши максимально возможное время; - в timeMin запиши 
минимально возможное время; - в time1 запиши время 14 часов ровно; - в time2 запиши время 7 часов 8 секунд; - в time3 
запиши время 0 часов 45 минут 61 наносекунда; - в time4 запиши время 14 часов 45 секунд 1001 наносекунда. В методе 
main() создай объект LocalTime, используя часы из time1 (time1.getHour()), минуты из time2, секунды из time3, 
наносекунды из time4. Выведи его в консоль.

***

task1611

Нужно просто посчитать

Цикл while в методе main должен отработать ровно четыре раза, чтобы на экран вывелись 4 строки. Изменения можно вносить 
только в метод amazingMethod.

***

task1612

Синтезируем LocalDateTime

В методе convert нужно преобразовать Map в Set. Принцип преобразования: если в sourceMap было два таких элемента: 
2018-05-31=[12:43:00.615424667, 08:35:29.212766273] 1998-01-31=[07:56:59.931458499] то в результате в множестве должно 
получиться три элемента: 2018-05-31T12:43:00.615424667 2018-05-31T08:35:29.212766273 1998-01-31T07:56:59.931458499

***

task1613

Фильтруем выходные

Реализуй метод isWeekend. Он должен определять, относится ли параметр dateTime к выходным. Считаем выходными промежуток 
между 22:00 пятницы (включительно) и 23:00 воскресенья (не включительно).

***

task1614

Конец времен

В классе Solution реализуй три метода: - в методе getMaxFromMilliseconds верни максимальный Instant, который можно 
получить с помощью метода ofEpochMilli(long milliseconds); - в методе getMaxFromSeconds верни максимальный Instant, 
который можно получить с помощью метода ofEpochSecond(long seconds); - в методе getMaxFromSecondsAndNanos верни 
максимальный Instant, который можно получить с помощью метода ofEpochSecond(long seconds, long nanos).

***

task1615

Ой как много методов!

В классе Solution реализуй шесть методов: - в методе plusMinutes нужно увеличить параметр instant на minutes минут и 
вернуть результат; - в методе plusHours нужно увеличить параметр instant на hours часов и вернуть результат; - в методе 
plusDays нужно увеличить параметр instant на days дней и вернуть результат; - в методе minusMinutes нужно уменьшить 
параметр instant на minutes минут и вернуть результат; - в методе minusHours нужно уменьшить параметр instant на hours 
часов и вернуть результат; - в методе minusDays нужно уменьшить параметр instant на days дней и вернуть результат;

***

task1616

Тренировка временных зон

Что общего у всех временных зон и Пекина? Правильно! Они позволят нам потренироваться в использовании классов ZoneId и 
ZonedDateTime :) Реализуй два метода: - в методе getSortedZones верни множество TreeSet всех временных зон; - в методе 
getBeijingTime верни текущее время в Пекине (временная зона для него — "Asia/Shanghai").

***

task1617

Временная глобализация

В методе main присвой значение переменной globalTime, используя переменные localDateTime и zoneId.

***

task1618

Лишь бы не запутаться

Можно ли, зная время в одном часовом поясе, определить время в другом? Реши эту задачу в методе changeZone. Его 
параметры: fromTime - известное время; fromZone - временная зона, в которой известно время; toZone - временная зона, в 
которой нужно определить время.

***

task1619

Простой шаблон

В методе main выведи на экран переменную localDateTime в таком виде: 19.03.2020г. 5ч.4мин

***

task1620

Еще один простой шаблон

В методе main выведи на экран переменную zonedDateTime в таком виде: 4 9.3.19 06:03:07.319180500 Europe/Kiev Где: 4 - 
номер дня недели, т.е. четверг; 9 - день месяца; 3 - месяц; 19 - год; 06 - часы; 03 - минуты; 07 - секунды; 319180500 - 
наносекунды; Europe/Kiev - временная зона.

***

task1621

Напиши шаблон

Инициализируй статическую переменную dateTimeFormatter. Подумай, какой шаблон ей задать, чтобы можно было распарсить 
строку timeString. В методе main создай объект LocalDateTime, используя строку timeString и твой шаблон 
dateTimeFormatter.