task1701

Правильное движение

Класс Bat (летучая мышь) унаследован от класса Animal. Все логично, вот только при вызове метода move() у объекта класса 
Bat выведется в консоли "Я бегу!".
Зачем бежать, если ты умеешь летать?
Переопредели метод move() для класса Bat, чтобы он выводил в консоли "Я лечу!".
Метод main() в тестировании участия не принимает.

***

task1702

Геометрия для чайников

Классы Triangle, Rectangle и Circle — геометрические фигуры, поэтому они и унаследованы от класса Shape.
Переопредели в них метод printInfo(), чтобы в консоли выводилось название конкретной фигуры:
Для Triangle — "Треугольник";
Rectangle — "Прямоугольник";
Circle — "Круг".

Метод main() в тестировании участия не принимает.

***

task1703

Космическая одиссея ч.1 

Перед тем, как космический корабль отправится бороздить просторы Вселенной, необходимо пригласить на борт экипаж, 
который будет состоять из 2 людей, 1 собаки и 1 кота.
В методе createCrew() добавь необходимое количество экземпляров соответствующих классов в список astronauts.

Подсказка:
Чтобы добавить объекты разных классов в один список, им нужен общий предок. Унаследуй интересующие тебя классы от 
Astronaut. Кто угодно может стать исследователем космоса :)

***

task1704

Космическая одиссея ч.2

Все члены экипажа космического корабля находятся на борту, корабль успешно вышел в открытый космос.
Команде пора приступить к выполнению своих обязанностей:
Людям — пилотировать корабль, Собаке — заниматься навигацией, а Коту — исследовать открытый космос.

Распредели обязанности членов экипажа в методе runWorkingProcess().

Для этого достань из списка astronauts всех людей (ты знаешь, под какими индексами они находятся) и передай их в 
качестве аргументов методу pilot(Human human), собаку передай в метод createDirection(Dog dog), а кота — в метод 
research(Cat cat).
Другие методы не изменяй.

Подсказка:
Список astronauts содержит объекты типа Astronaut. Чтобы вызвать методы pilot(), createDirection() и research(), 
сначала объект Astronaut нужно привести к правильному типу.

***

task1704

Космическая одиссея ч.3

Сделаем наш предыдущий пример более правильным и универсальным.
Порядок, в котором добавляются астронавты в список astronauts, не всегда будет известен. Чтобы правильно распределить 
задачи членам экипажа, необходимо определить, кем является астронавт. Для этого в методе runWorkingProcess() перебери 
всех астронавтов в цикле, используя оператор instanceof определи, кем является астронавт и передай его в качестве 
аргумента соответствующему методу:
Human — в метод pilot(Human human);
Dog — в метод createDirection(Dog dog);
Cat — в метод research(Cat cat).

Метод runWorkingProcess() должен работать корректно независимо от количества астронавтов и порядка их добавления в 
astronauts.

***

task1706

Хищники vs Травоедные

Перед тобой 4 класса животных — Cow, Lion, Wolf и Elephant. Корова (Cow) и слон (Elephant) являются травоядными, 
поэтому они наследуются от класса Herbivore.
А лев (Lion) и волк (Wolf) являются хищниками, поэтому они наследуются от класса Predator. В свою очередь классы 
Herbivore и Predator унаследованы от Animal.
В классе Solution реализуй метод printRation(Animal animal), который должен выводить в консоли рацион переданного 
животного:

    *если животное хищник, нужно вывести "Любит мясо";
    *если животное травоядное, вывести "Любит траву".
   
***

task1707

Питомцы бывают разные

Класс Pet является родительским классом для классов Cat и Dog. В нем реализован метод printInfo(), который сообщает, 
что данный объект является питомцем.
В классах Cat и Dog переопредели метод printInfo(), дополнив его функционал следующим образом:

*   вначале вызови метод printInfo() родительского класса;
*   потом дополнительно выведи в консоли "Я не люблю людей" для класса Cat или "Я люблю людей" для класса Dog.

Пример вывода для класса Cat:
    
    Я домашний питомец.
    Я не люблю людей.

Пример вывода для класса Dog:

    Я домашний питомец.
    Я люблю людей.
    
***

task1708

Минимальное и максимальное

В этой задаче тебе предстоит создать универсальный инструмент для поиска минимальных и максимальных чисел.
В классе MinMaxUtil создай публичные статические методы min() и max(), которые в качестве аргументов принимают 
целочисленные (тип int) значения и возвращают минимальное и максимальное из них соответственно.

Каждый из методов должен быть перегружен так, чтобы была возможность вызвать метод с двумя, тремя, четырьмя и пятью 
параметрами.
В общем, необходимо создать 8 методов, — 4 для min() и 4 для max().
Все аргументы методов должны быть типа int.

***

task1709

Абстрактные фигуры

Класс Shape обозначает геометрическую фигуру. В будущем от него можно будет унаследовать какую-то конкретную фигуру.
У этой фигуры можно будет посчитать периметр и площадь. У разных фигур они считаются по разным формулам.
И так как ни периметр, ни площадь невозможно высчитать у абстрактной фигуры, класс Shape стоит сделать абстрактным.

Также сделай задел на будущее и создай в нем абстрактные методы getPerimeter() и getArea(). Методы будут возвращать 
значение типа double.

***

task1710

От абстракции к реальности

Класс Person объявлен как абстрактный. Это значит, что мы не можем создавать его экземпляры.
Сделай из данного класса обычный, допиши недостающую логику, которая отвечает общепринятым подходам к инкапсуляции:
геттеры должны возвращать, а сеттеры — устанавливать значения соответствующим полям.

***

task1711

Способы передвижения

Создай два интерфейса — Swimmable и Flyable.
В будущем их можно будет использовать для обозначения классов, объекты которых умеют плавать или летать.

***

task1712

Съедобное - несъедобное

Имплементируй интерфейс Eatable только для классов, объекты которых могут быть съедобными, из этого списка:
Apple — яблоко
Carrot — морковь
Fire — огонь
Fish — рыба
Stone — камень

***

task1713

Да начнется представление!

Настоящий артист должен уметь развлечь людей. И танцы, и пение — это часть развлечения.
Перед тобой 3 интерфейса:
Dance — танцующий,
Sing — поющий,
Artist — артист.

Продумай, какая структура наследования подойдет этим интерфейсам. Унаследуй один интерфейс от двух других.

***

task1714

Летать или плавать

Существуют 2 интерфейса — Swimmable и Flyable, указывающие на то, что объект умеет плавать и/или летать соответственно.
Расставь эти интерфейсы для классов Zeppelin (Дирижабль), Ship (Корабль) и JamesBondCar (Машина Джеймса Бонда) в 
соответствии с их возможностями.

Помни: машина Джеймса Бонда умеет все.

***

task1715

Вилларибо и Виллабаджо.

В деревне Вилларибо есть струнный оркестр, а в деревне Виллабаджо — клавишный.
Как-то раз повозки с музыкантами из двух деревень столкнулись на перекрестке, и все смешалось в кучу.
Помоги артистам разобрать свои инструменты. И естественно, после этого оба оркестра должны дать концерт.

Для этого:

*   в методе createKeyboardOrchestra() добавь в список orchestra один орган и три пианино;
*   в методе createStringedOrchestra() добавь в список orchestra две скрипки и одну гитару;
*   метод playOrchestra() должен вызывать метод play() у всех элементов списка orchestra.

***

task1716

Дорожное движение

Классы Car и Bus имплементируют интерфейс Vehicle. При этом имплементации некоторых его методов у них сходятся.
Реализуй эти методы как default в самом интерфейсе Vehicle, а из классов Car и Bus их убери.

***

task1717

Кто летит?

Классы Eagle (Орел), Raven (Ворон) и Aircraft (Самолет) имплементируют интерфейс Flyable, который содержит дефолтную 
реализацию метода int getMaxSpeed() и возвращает значение 80.
Такая реализация неправильная, так как реальная максимальная скорость Орла — 180 км/ч, Ворона — 48, а самолета — 1200.

Тебе нужно убрать дефолтную реализацию метода getMaxSpeed() из интерфейса Flyable (сам метод нужно оставить) и 
имплементировать его в каждом из классов.
Для каждого класса укажи правильное значение максимальной скорости.