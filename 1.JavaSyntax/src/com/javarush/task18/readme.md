task1801

Две реализации одного интерфейса

В интерфейсе Runnable объявлен метод run() и есть две его реализации: в классе Car и в классе Plane.
В классе Solution есть публичное статическое поле ArrayList<Runnable> list, а также два публичных статических метода:
addToList(Runnable), который добавляет в список list элемент, полученный в качестве входного параметра, и метод 
runList(), который вызывает метод run() у каждого элемента списка list.
Твоя задача — реализовать эти методы.

Метод main() не участвует в тестировании.

***

task1802

Сортировка по возрасту

В классе Solution есть статическое поле students, которое заполняется студентами (объектами типа Student) в методе 
main().
У студента (класс Student) есть имя (поле name) и возраст (поле age). Нужно отсортировать в программе студентов по 
возрасту в убывающем порядке (от старшего к младшему).
Для этого используется метод Collections.sort(ArrayList<Student>, Comparator<Student>), в который передается список 
студентов students и компаратор сортировки по убыванию возраста.

Твоя задача — реализовать этот компаратор. Для этого в классе AgeComparator нужно имплементировать интерфейс 
Comparator<Student> и реализовать метод int compare(Student student1, Student student2), который возвращает числовое 
значение со следующими условиями:

* отрицательное число, если возраст студента student1 больше возраста студента student2;
* положительное число, если возраст студента student1 меньше возраста студента student2;
* 0, если возраст студентов student1 и student2 одинаковый.
    
Метод main() не принимает участие в тестировании.

***

task1803

Наставники JavaRush

В классе Solution есть статическое поле mentors, которое заполняется менторами JavaRush (объектами типа JavaRushMentor) 
в методе main().
У ментора (класс JavaRushMentor) есть имя (поле name). В программе нужно отсортировать менторов по длине имени в 
возрастающем порядке (от самого короткого до самого длинного).

Чтобы отсортировать всех менторов в списке mentors используется метод 
Collections.sort(ArrayList<JavaRushMentor>, Comparator<JavaRushMentor>), в который передается список менторов mentors и 
компаратор сортировки.

Твоя задача — реализовать этот компаратор. Для этого в классе NameComparator нужно имплементировать интерфейс 
Comparator<JavaRushMentor> и реализовать метод int compare(JavaRushMentor mentor1, JavaRushMentor mentor2), который 
возвращает числовое значение со следующими условиями:

* отрицательное число, если длина имени ментора mentor1 меньше длины имени ментора mentor2;
* положительное число, если длина имени ментора mentor1 больше длины имени ментора mentor2;
* 0, если длины имен менторов mentor1 и mentor2 одинаковы.

Метод main() не принимает участие в тестировании.

***

task1804

Знакомство с лямбда-выражением

Перед тобой программа, которая сортирует список чисел по возрастанию.
Метод sortNumbers(ArrayList<Integer>) принимает список, элементы которого необходимо отсортировать. Для сортировки 
используется метод Collections.sort(ArrayList<Integer>, Comparator<Integer>), параметрами которого являются список 
чисел и компаратор.

Твоя задача — переписать реализацию метода sortNumbers(ArrayList<Integer>), чтобы вместо использования внутреннего 
анонимного класса Comparator<Integer> использовалось лямбда-выражение.

Метод main() не принимает участие в тестировании.

***

task1805

Прощание с лямбда-выражением

Перед тобой программа, которая сортирует список строк по их длине по возрастанию.
Это делает метод sortStringsByLength(ArrayList<String>). Для сортировки строк используется метод 
Collections.sort(ArrayList<String>, Comparator<String>), который принимает список строк и компаратор в виде 
лямбда-выражения.

Твоя задача — переписать реализацию метода sortStringsByLength(ArrayList<String>), чтобы вместо лямбда-выражения 
использовался класс StringComparator, который реализует интерфейс Comparator<String>, не меняя логику работы метода 
sortStringsByLength(ArrayList<String>).

То есть нужно, чтобы в классе StringComparator метод int compare(String s1, String s2) возвращал числовое значение 
согласно этим условиям:

* отрицательное число, если длина строки s1 меньше длины строки s2;
* положительное число, если длина строки s1 больше длины строки s2;
* 0, если длины строк s1 и s2 одинаковы.

Метод main() не принимает участие в тестировании.

***

task1806

Знакомство с foreach

В классе Solution публичный метод print(ArrayList<Integer>) выводит в консоли все элементы списка по порядку.
Сейчас метод реализован с использованием оператора for. Необходимо переписать реализацию метода 
print(ArrayList<Integer>), используя метод списка forEach(), принимающий лямбда-выражение. Логику работы метода 
print(ArrayList<Integer>) менять не нужно.

Метод main() не принимает участие в тестировании.

***

task1807

Прощание с foreach

В классе Solution публичный метод print(ArrayList<String>) выводит в консоли все элементы списка по порядку.
Сейчас метод реализован с использованием метода списка forEach(). Необходимо переписать реализацию метода 
print(ArrayList<String>), используя оператор for, не меняя логику работы метода.

Метод main() не принимает участие в тестировании.

***

task1808

Знакомство со ссылками на методы

В классе Solution публичный метод print(ArrayList<String>) выводит в консоли все элементы списка по порядку.
Сейчас метод реализован с использованием метода списка forEach(), который принимает лямбда-выражение. Необходимо 
переписать реализацию метода print(ArrayList<String>), чтобы метод списка forEach() вместо лямбда-выражения принимал 
ссылку на метод.

Метод main() не принимает участие в тестировании.

***

task1809

Прощание со ссылками на методы

В классе Solution публичный метод print(ArrayList<Integer>) выводит в консоли все элементы списка по порядку.
Сейчас метод реализован с использованием метода списка forEach(), который принимает ссылку на метод. Необходимо 
переписать реализацию метода print(ArrayList<Integer>), чтобы метод списка forEach() вместо ссылки на метод принимал 
лямбда-выражения.

Метод main() не принимает участие в тестировании.

***

task1810

Преобразование списка в массив

В классе Solution есть два публичных статических метода:

* String[] toStringArray(ArrayList<String>), в котором нужно преобразовать список строк в массив строк и вернуть его;
* Integer[] toIntegerArray(ArrayList<Integer>), в котором нужно преобразовать список чисел в массив чисел и вернуть его.

Для преобразования списка в массив используй метод списка toArray(), в который нужно передать ссылку на конструктор 
массива, тип которого соответствует типу списка.
Метод main() не принимает участие в тестировании.

***

task1811

Получение потока Stream

В этой задаче тебе нужно реализовать два метода так, чтобы:

1. Публичный статический метод getStreamFromArrayList(ArrayList<String>) возвращал поток строк из списка строк, 
полученного в качестве аргумента.
2. Публичный статический метод getStreamFromArray(Integer[] array) возвращал поток чисел из массива чисел, полученного в 
качестве аргумента.

Подсказка:
Чтобы получить поток данных у коллекции, нужно вызвать у нее метод stream().
Чтобы получить поток данных у массива, нужно вызвать у класса java.util.Arrays статический метод stream(), в который 
передать массив.

Метод main() не принимает участие в тестировании.

***

task1812

Рейтинг языков программирования

Класс Language представляет собой модель языка программирования. В этом классе есть два поля: name - название языка 
программирования, ranking - рейтинг использования языка программирования по состоянию на сентябрь 2020 года, согласно 
TIOBE.
Нужно, чтобы публичный статический метод sortByRanking(ArrayList<Language>) сортировал полученный список языков 
программирования по убыванию рейтинга, и возвращал отсортированный поток данных (Stream<Language>).

Подсказка:
Поскольку поле рейтинг имеет тип Double, для сортировки нужно использовать статический метод compare(Double, Double) 
класса Double или метод compareTo(Double) объекта типа Double.

Метод main() не принимает участие в тестировании.

***

task1813

Будущее за электрокарами

Современный мир отказывается от двигателей внутреннего сгорания, и эра электрокаров не за горами. Нужно, чтобы наша 
программа могла отфильтровать электрокары от всех остальных автомобилей.
Для этих целей есть метод onlyElectricCars(ArrayList<Car>), который фильтрует список автомобилей, получаемых в качестве 
входящего параметра. Этот метод возвращает поток отфильтрованных данных, а именно — поток автомобилей, у которых поле 
isElectric равно true. В этом тебе поможет метод filter() объекта типа Stream<Car>.

Метод main() не принимает участие в тестировании.

***

task1814

Без повторов

Метод getDistinct(ArrayList<String>) получает список слов, в котором содержатся повторы. Твоя задача — реализовать этот 
метод так, чтобы он возвращал поток слов без повторов (каждое слово — по одному разу).
В этом тебе поможет метод distinct() объекта типа Stream<String>.

Метод main() не принимает участие в тестировании.

***

task1815

Преобразование данных

У учетной записи (класс Account) есть имя (поле name) и электронный ящик (поле email). Нужно, чтобы метод 
getEmails(ArrayList<Account>) в классе Solution возвращал поток электронных ящиков всех учетных записей из списка, 
полученного в качестве входящего аргумента.

Подсказка:
Для преобразования потока данных одного типа в другой используй метод map() объекта типа Stream<Account>.

Метод main() не принимает участие в тестировании.

***

task1816

Преобразование данных-2

Реализуй метод toUpperCase(Stream<String>) так, чтобы он возвращал поток таких же строк, что и во входящем потоке, 
только в верхнем регистре.
Поскольку это будет поток уже других строк, для преобразования используй метод map() объекта типа Stream<String>.

Метод main() не принимает участие в тестировании.

***

task1817

Анализ потока чисел

Программа анализирует поток чисел. Логика программы следующая:

1. Метод hasNegativeEvenNumbers(Stream<Integer>) возвращает true, если во входящем потоке есть хотя бы одно 
отрицательное четное число и false, если таких чисел нет. Для поиска чисел в потоке используй метод anyMatch() объекта 
типа Stream<Integer>.
2. Метод hasOnlyPositiveNumbers(Stream<Integer>) возвращает true, если во входящем потоке есть только положительные 
числа и false, если есть хотя бы одно отрицательное число. Для поиска чисел в потоке используй метод allMatch() объекта 
типа Stream<Integer>.
3. Метод hasOnlyNegativeNumbers(Stream<Integer>) возвращает true, если во входящем потоке есть только отрицательные 
числа и false, если есть хотя бы одно положительное число. Для поиска чисел в потоке используй метод noneMatch() 
объекта типа Stream<Integer>.

Метод main() не принимает участие в тестировании.

***

task1818

Просрочен ли товар?

В классе Solution метод hasExpiredProduct(Stream<Product>) возвращает true, если во входящем потоке товаров есть хотя 
бы один просроченный и возвращать false, если таких товаров нет.

Чтобы это проверить, нужно у каждого товара в потоке сравнить поле expirationDate (годен до) типа LocalDate с текущей 
датой (статический метод now() класса LocalDate). Если срок годности меньше (строго) текущей даты, то в этом потоке 
есть просроченные товары.
Для поиска таких товаров в потоке используй метод anyMatch() объекта типа Stream<Product>.

Метод main() не принимает участие в тестировании.

***

task1819

Как быть, если в списке есть элемент null

Задача метода printList(List<String>) — вывести в консоли все элементы списка, полученного как параметр, в том же 
порядке. Но есть один нюанс. В списке могут быть элементы, равные null.

Твоя задача — вывести все элементы списка в консоли, а вместо null — фразу: Этот элемент равен null
В методе printList(List<String>) нельзя использовать циклы, оператор if/else и тернарный оператор.
Для проверки равенства строки на null и замены её на другую строку есть метод orElse объекта типа Optional<String>.

Метод main() не принимает участие в тестировании.

***

task1820

Самый дорогой автомобиль

У автомобиля, представленного классом Car, есть две характеристики: название - поле name, цена - поле price.
В классе Solution выполняются две операции поиска:

* метод getMostExpensiveCar(Stream<Car>) ищет самый дорогой автомобиль в одном списке;
* метод getMoreExpensiveCar(Stream<Car>, Car) в другом списке ищет автомобиль дороже, чем полученный в методе 
getMostExpensiveCar(Stream<Car>).

Методы возвращают не сам автомобиль (объект типа Car), а объект типа Optional<Car>.
Подсказка:
Для поиска элемента с максимальным искомым значением в потоке данных используй метод max(), а чтобы найти первый 
попавшийся подходящий элемент из потока отфильтрованных данных используй метод findFirst().

Метод main() не принимает участие в тестировании.

***

task1821

Самый дешевый автомобиль

У автомобиля, представленного классом Car, есть две характеристики: название - поле name, цена - поле price.
В классе Solution выполняются две операции поиска:

* метод getCheapestCar(Stream<Car>) ищет самый дешевый автомобиль в одном списке;
* метод getCheaperCar(Stream<Car>, Car) в другом списке ищет автомобиль дешевле, чем полученный в методе 
getCheapestCar(Stream<Car>).

Методы возвращают не сам автомобиль (объект типа Car), а объект типа Optional<Car>.

Подсказка:
Для поиска элемента с минимальным искомым значением в потоке данных используй метод min(), а чтобы найти первый 
попавшийся подходящий элемент из потока отфильтрованных данных используй метод findFirst().

Метод main() не принимает участие в тестировании.

***

task1822

Из потока данных в список

Для решения этой задачи необходимо, чтобы метод getPositiveNumbers(Stream<Integer>) преобразовывал входящий поток чисел 
в список чисел больше нуля.
Реализуй его, используя метод collect() объекта типа Stream<Integer>. В качестве параметра передай нужный коллектор 
(объект типа Collector<List<Integer>>). Такой объект можно получить, вызвав статический метод toList() класса Collectors.

Метод main() не принимает участие в тестировании.

***

task1823

Из потока данных во множество

Необходимо, чтобы метод getFilteredStrings(Stream<String>) преобразовывал входящий поток строк во множество строк, 
длина которых больше шести символов.
Реализуй его, используя метод collect() объекта типа Stream<String>. В качестве параметра передай нужный коллектор 
(объект типа Collector<Set<String>>). Такой объект можно получить, вызвав статический метод toSet() класса Collectors.

Метод main() не принимает участие в тестировании.

***

task1824

Из потока данных — в map

Необходимо, чтобы метод getMap(Stream<String>) преобразовывал входящий поток строк в карту (map), ключом которой 
является сама строка, а значением — её длинна.
Реализуй его, используя метод collect() объекта типа Stream<String>. В качестве параметра передай нужный коллектор 
(объект типа Collector<Map<String, Integer>>). Такой объект можно получить, вызвав статический метод toMap() класса 
Collectors.

Метод main() не принимает участие в тестировании.

***

task1825

Из потока данных — в строку

Необходимо, чтобы метод getString(Stream<String>) преобразовывал входящий поток строк в строку, слова в которой нужно 
разделить пробелом. Порядок слов в строке должен соответствовать порядку элементов в потоке.
Реализуй его, используя метод collect() объекта типа Stream<String>. В качестве параметра передай нужный коллектор 
(объект типа Collector<String>). Такой объект можно получить, вызвав статический метод joining() класса Collectors.

Метод main() не принимает участие в тестировании.