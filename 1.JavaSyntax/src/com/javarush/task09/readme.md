task0901

Целочисленные литералы

В классе Solution объявлены четыре публичных поля, которые соответствуют четырем целочисленным типам. 
При объявлении эти поля инициализируются разными значениями — целочисленными литералами.
Но программа не компилируется, и нужно это исправить. 
Для этого внеси минимальные изменения в значения полей так, чтобы тип переменной соответствовал типу 
целочисленного литерала.
Можно изменять только знак и тип литерала, не изменяя цифры и их порядок.

***

task0902

Литералы с плавающей точкой

В классе Solution объявлены и проинициализированы семь публичных полей.
Они инициализируются разными значениями — литералами с плавающей точкой. Но программа не компилируется, 
и нужно это исправить. Для этого измени типы полей, чтобы они соответствовали значениям. 
Имена и значения полей не изменяй.

***

task0903

Строковые литералы

В классе Solution объявлено и проинициализировано публичное строковое поле. Но строка слишком длинная и неудобочитаемая.
Для лучшей читаемости нужно разделить её на 5 подстрок и склеить их "оператором +" (конкатенация строк) в таком виде:
первая строка: "Всегда пишите код так, "
вторая строка: "будто сопровождать его будет "
третья строка: "склонный к насилию психопат, "
четвертая строка: "который знает, где вы живете. "
пятая строка: "Martin Golding"

***

task0904

Символьные литералы

В классе Solution объявлены четыре публичных символьных поля. Им присвоены некоторые значения. 
Но программа не компилируется. Нужно это исправить, не меняя значения символов.
Все поля статические (static) — это нужно, чтобы в методе main() получить к ним доступ.
На результат можно посмотреть, запустив метод main(). Он не принимает участие в тестировании.

***

task0905

Публичный статический метод toOctal(int) должен переводить целое число, полученное в качестве входящего параметра, из десятичной системы счисления в восьмеричную. А публичный статический метод toDecimal(int) наоборот — из восьмеричной в десятичную.
Методы работают только с положительными числами. Если входящий параметр меньше или равен 0, методы возвращают 0.
Твоя задача — реализовать эти методы.
Один из алгоритмов перевода десятичного числа в восьмеричное следующий:
i равно 0
while(десятичное число не равно 0) {
восьмеричное число = восьмеричное число + (остаток от деления десятичного числа на 8) * на 10 в степени i
десятичное число = десятичное число / 8
i увеличиваем на 1
}
Один из алгоритмов перевода восьмеричного числа в десятичное следующий:
i равно 0
while(восьмеричное число не равно 0) {
десятичное число = десятичное число + (остаток от деления восьмеричного числа на 10) * на 8 в степени i
восьмеричное число = восьмеричное число / 10
i увеличиваем на 1
}
Метод main() не принимает участие в тестировании.
Подсказка: чтобы возвести число в степень, можно использовать метод Math.pow(число, степень).

***

task0906

Двоичный конвертер

Публичный статический метод toBinary(int) должен переводить целое число, полученное в качестве входящего параметра, 
из десятичной системы счисления в двоичную и возвращать его строковое представление. 
А публичный статический метод toDecimal(String) наоборот — из строкового представления двоичного числа в 
десятичное число.
Методы работают только с положительными числами и не пустыми строками. Если входящий параметр меньше или равен 0, 
метод toBinary(int) возвращает пустую строку. Если входящий параметр — пустая строка или null, 
то метод toDecimal(String) возвращает 0.
Твоя задача — реализовать эти методы.
Один из алгоритмов перевода десятичного числа в представление двоичного числа следующий:
while(десятичное число не равно 0) {
двоичное представление = остаток от деления десятичного числа на 2 + двоичное представление
десятичное число = десятичное число / 2
}
Один из алгоритмов перевода представления двоичного числа в десятичное число следующий:
for (int i = 0; i < длины двоичного представления; i++) {
десятичное число = десятичное число + число из двоичного представления * на 2 в степени i
}
Изначально берется крайнее правое число из двоичного представления. С каждой итерацией цикла берется следующее число 
ближе к началу двоичного представления.
Подсказка: чтобы возвести число к степени можно использовать метод Math.pow(число, степень).
Метод main() не принимает участие в тестировании.

***

task0907

Шестнадцатеричный конвертер

Публичный статический метод toHex(int) должен переводить целое число, полученное в качестве входящего параметра, 
из десятичной системы счисления в шестнадцатеричную и возвращать его строковое представление. А публичный статический 
метод toDecimal(String) наоборот — из строкового представления шестнадцатеричного числа в десятичное число.
Методы работают только с положительными числами и не пустыми строками. Если входящий параметр меньше или равен 0, 
метод toHex(int) возвращает пустую строку. Если входящий параметр — пустая строка или null, то метод toDecimal(String) 
возвращает 0.
Твоя задача реализовать эти методы.
Также в классе Solution есть константа HEX, которая содержит в себе все символы, используемые в шестнадцатеричной 
системе.
Один из алгоритмов перевода десятичного числа в шестнадцатеричное следующий:
while(десятичное число не равно 0) {
представление шестнадцатеричного числа = символ из строки HEX с индексом, равным остатку от деления десятичного числа 
на 16
+ представление шестнадцатеричного числа
десятичное число = десятичное число / 16
}
Один из алгоритмов перевода шестнадцатеричного числа в десятичное следующий:
for (int i = 0; i < длина входящей строки; i++) {
десятичное число = 16 * десятичное число + индекс символа из строки HEX, равного символу из входящей строки с индексом i
}
Метод main() не принимает участие в тестировании.

***

task0908

Двоично-шестнадцатеричный конвертер

Публичный статический метод toHex(String) должен переводить строковое представление двоичного числа, полученное 
в качестве входящего параметра, из двоичной системы счисления в шестнадцатеричную и возвращать его строковое 
представление. А публичный статический метод toBinary(String) наоборот — из строкового представления шестнадцатеричного 
числа в строковое представление двоичного числа.
Методы работают только с не пустыми строками.
Если входящий параметр — пустая строка или null, то оба метода возвращают пустую строку.
Если входящий параметр метода toHex(String) содержит любой символ, кроме 0 или 1, то метод возвращает пустую строку.
Если входящий параметр метода toBinary(String) содержит любой символ, кроме цифр от 0 до 9 или латинскую букву от a до 
f (в нижнем регистре), то метод возвращает пустую строку.
Твоя задача — реализовать эти методы.
Один из алгоритмов перевода строкового представления двоичного числа в строковое представление шестнадцатеричного числа 
следующий:
Проверяем длину строки, полученной входящим параметром. Она должна быть кратна 4.
Если это не так, то добавляем нужное количество 0 в начало строки.
Берем каждые четыре символа (бита) и проверяем, какому символу шестнадцатеричной кодировки он соответствует.
Например:
двоичное представление — "100111010000", где "1001" — "9", "1101" — "d", "0000" — "0",
шестнадцатеричное представление — "9d0".
Один из алгоритмов перевода строкового представления шестнадцатеричного числа в строковое представление двоичного числа 
следующий:
Берем каждый символ и проверяем какому двоичному числу (4 бита) он соответствует.
Например:
шестнадцатеричное представление — "9d0", где "9" — "1001", "d" — "1101", "0" — "0000",
двоичное представление — "100111010000".
Метод main() не принимает участие в тестировании.

***

task0909

Экранирование символов

Выведи на экран следующий текст в две строки:
It's a Windows path: "C:\Program Files\Java\jdk-13.0.0\bin"
It's a Java string: \"C:\\Program Files\\Java\\jdk-13.0.0\\bin\"

Подсказка:
\” – экранирование двойной кавычки;
\\ – экранирование обратной косой черты (\).

Больше про экранирование символов и Escape-последовательности в Java читай в статье "Экранирование символов в Java".

***

task0910

Кодировка Unicode

В публичный статический метод init(char[]) передается массив символов размером 9, который нужно заполнить следующими 
символами:
0 - '\u00A9'
1 - '\u004A'
2 - '\u0061'
3 - '\u0076'
4 - '\u0061'
5 - '\u0052'
6 - '\u0075'
7 - '\u0073'
8 - '\u0068'

Чтобы посмотреть результат, запусти метод main().

***

task0911

Поздравление

Проинициализируй статические переменные следующими значениями:

partyFace — "\uD83E\uDD73"
balloon — "\uD83C\uDF88"
gift — "\uD83C\uDF81"
partyPopper — "\uD83C\uDF89"
cake — "\uD83C\uDF82"

Чтобы посмотреть поздравление, запусти метод main().

***

task0912

Проверка URL-адреса

В этой задаче тебе нужно выполнить проверку URL-адреса.

Простая схема URL-адреса выглядит так:
<сетевой протокол>://<название ресурса>.<домен>

Метод checkProtocol(String) проверяет, какой сетевой протокол (http или https) у URL-адреса, полученного входящим 
параметром, и возвращает результат проверки — строку название сетевого протокола. А метод checkDomain(String) проверяет, 
какой домен (com, net, org или ru) у URL-адреса, полученного входящим параметром, и возвращает результат проверки — 
строку название домена.

Если URL-адрес начинается не с http или https, то результат будет — "неизвестный". Если URL-адрес заканчивается не на 
com, net, org или ru, то результат будет — "неизвестный".

main не принимает участие в тестировании.

***

task0913

Поиск в строке

Метод getIndexFromFirstWord(String, String) и метод getIndexFromLastWord(String, String) принимают строку и слово.
Нужно, чтобы метод getIndexFromFirstWord(String, String) вернул индекс первого символа первого слова (второй параметр 
метода) в строке (первый параметр метода). А метод getIndexFromLastWord(String, String) вернул индекс первого символа 
последнего слова (второй параметр метода) в строке (первый параметр метода).

Пример:
строка — "Чтобы стать программистом, нужно писать код. Чтобы писать код, нужно учиться. Чтобы учиться, нужно желание."
слово — "код"

метод getIndexFromFirstWord(строка, слово) должен вернуть 40
метод getIndexFromLastWord(строка, слово) должен вернуть 58
Метод main() не принимает участия в тестировании.

***

task0914

Обновление пути

Реализуй метод changePath(String, String) так, чтобы он заменял версию jdk в пути, полученном первым параметром метода, 
на версию, полученную вторым параметром, и возвращал новый путь.
Версия jdk начинается со строки "jdk" и заканчивается на "/".

Пример:
путь — "/usr/java/jdk1.8/bin"
версия jdk — "jdk-13"

Метод changePath(путь, версия jdk) должен вернуть путь — "/usr/java/jdk-13/bin".
Метод main() не принимает участия в тестировании.

***

task0915

StringTokenizer

Используя StringTokenizer раздели query на части по разделителю delimiter.
Максимально возможное количество токенов - 6.

Пример:
getTokens("java.util.stream", "\\.")
возвращает массив строк
{"java", "util", "stream"}

***

task0916

String.format()

Сделай так, чтобы метод format(String name, int salary) возвращал строку в таком виде:
Меня зовут <name>. Я буду зарабатывать $<salary> в месяц.

Для этого используй метод String.format().

***

task0917

Метод equal(String, String) сравнивает строки по ссылке, используя оператор ==.
Нужно сделать так, чтобы метод возвращал true, если содержимое строк одинаковое, и false — если разное, не используя 
метод equals().

***
